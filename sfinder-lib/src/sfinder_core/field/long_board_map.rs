//! Lookup values are generated by MapGenerator
// We skip the ANDing of VALID_BOARD_RANGE when the x is unmodified because we assume the x is already valid
use crate::common::generator::wrapper::wrapper;

#[inline]
const fn row_mask(filled: u8, bottom_empty: u8) -> u64 {
    ((1 << (filled * 10)) - 1) << (bottom_empty * 10)
}

// inlined at compile time
// minimized name for formatting
const fn rm(filled: u8, bottom_empty: u8) -> u64 {
    row_mask(filled, bottom_empty)
}

pub fn delete_row(x: u64, mask: u64) -> u64 {
    delete_line_inner(x, wrapper(mask))
}

fn delete_line_inner(x: u64, mask: u64) -> u64 {
    match mask {
        0b1100000000110000000011 => 0,
        0b1100000000110000000010 => x & rm(1, 0),
        0b1100000000100000000011 => (x >> 10) & rm(1, 0),
        0b1100000000100000000010 => x & rm(2, 0),
        0b1000000000110000000011 => (x >> 20) & rm(1, 0),
        0b1000000000110000000010 => x & rm(1, 0) | (x >> 10) & rm(1, 1),
        0b1000000000100000000011 => (x >> 10) & rm(2, 0),
        0b1000000000100000000010 => x & rm(3, 0),
        0b1100000000110000000001 => (x >> 30) & rm(1, 0),
        0b1100000000110000000000 => x & rm(1, 0) | (x >> 20) & rm(1, 1),
        0b1100000000100000000001 => (x >> 10) & rm(1, 0) | (x >> 20) & rm(1, 1),
        0b1100000000100000000000 => x & rm(2, 0) | (x >> 10) & rm(1, 2),
        0b1000000000110000000001 => (x >> 20) & rm(2, 0),
        0b1000000000110000000000 => x & rm(1, 0) | (x >> 10) & rm(2, 1),
        0b1000000000100000000001 => (x >> 10) & rm(3, 0),
        0b1000000000100000000000 => x & rm(4, 0),
        0b1100000000010000000011 => (x >> 40) & rm(1, 0),
        0b1100000000010000000010 => x & rm(1, 0) | (x >> 30) & rm(1, 1),
        0b1100000000000000000011 => (x >> 10) & rm(1, 0) | (x >> 30) & rm(1, 1),
        0b1100000000000000000010 => x & rm(2, 0) | (x >> 20) & rm(1, 2),
        0b1000000000010000000011 => (x >> 20) & rm(1, 0) | (x >> 30) & rm(1, 1),
        0b1000000000010000000010 => x & rm(1, 0) | (x >> 10) & rm(1, 1) | (x >> 20) & rm(1, 2),
        0b1000000000000000000011 => (x >> 10) & rm(2, 0) | (x >> 20) & rm(1, 2),
        0b1000000000000000000010 => x & rm(3, 0) | (x >> 10) & rm(1, 3),
        0b1100000000010000000001 => (x >> 30) & rm(2, 0),
        0b1100000000010000000000 => x & rm(1, 0) | (x >> 20) & rm(2, 1),
        0b1100000000000000000001 => (x >> 10) & rm(1, 0) | (x >> 20) & rm(2, 1),
        0b1100000000000000000000 => x & rm(2, 0) | (x >> 10) & rm(2, 2),
        0b1000000000010000000001 => (x >> 20) & rm(3, 0),
        0b1000000000010000000000 => x & rm(1, 0) | (x >> 10) & rm(3, 1),
        0b1000000000000000000001 => (x >> 10) & rm(4, 0),
        0b1000000000000000000000 => x & rm(5, 0),
        0b0100000000110000000011 => (x >> 50) & rm(1, 0),
        0b0100000000110000000010 => x & rm(1, 0) | (x >> 40) & rm(1, 1),
        0b0100000000100000000011 => (x >> 10) & rm(1, 0) | (x >> 40) & rm(1, 1),
        0b0100000000100000000010 => x & rm(2, 0) | (x >> 30) & rm(1, 2),
        0b0000000000110000000011 => (x >> 20) & rm(1, 0) | (x >> 40) & rm(1, 1),
        0b0000000000110000000010 => x & rm(1, 0) | (x >> 10) & rm(1, 1) | (x >> 30) & rm(1, 2),
        0b0000000000100000000011 => (x >> 10) & rm(2, 0) | (x >> 30) & rm(1, 2),
        0b0000000000100000000010 => x & rm(3, 0) | (x >> 20) & rm(1, 3),
        0b0100000000110000000001 => (x >> 30) & rm(1, 0) | (x >> 40) & rm(1, 1),
        0b0100000000110000000000 => x & rm(1, 0) | (x >> 20) & rm(1, 1) | (x >> 30) & rm(1, 2),
        0b0100000000100000000001 => {
            (x >> 10) & rm(1, 0) | (x >> 20) & rm(1, 1) | (x >> 30) & rm(1, 2)
        }
        0b0100000000100000000000 => x & rm(2, 0) | (x >> 10) & rm(1, 2) | (x >> 20) & rm(1, 3),
        0b0000000000110000000001 => (x >> 20) & rm(2, 0) | (x >> 30) & rm(1, 2),
        0b0000000000110000000000 => x & rm(1, 0) | (x >> 10) & rm(2, 1) | (x >> 20) & rm(1, 3),
        0b0000000000100000000001 => (x >> 10) & rm(3, 0) | (x >> 20) & rm(1, 3),
        0b0000000000100000000000 => x & rm(4, 0) | (x >> 10) & rm(1, 4),
        0b0100000000010000000011 => (x >> 40) & rm(2, 0),
        0b0100000000010000000010 => x & rm(1, 0) | (x >> 30) & rm(2, 1),
        0b0100000000000000000011 => (x >> 10) & rm(1, 0) | (x >> 30) & rm(2, 1),
        0b0100000000000000000010 => x & rm(2, 0) | (x >> 20) & rm(2, 2),
        0b0000000000010000000011 => (x >> 20) & rm(1, 0) | (x >> 30) & rm(2, 1),
        0b0000000000010000000010 => x & rm(1, 0) | (x >> 10) & rm(1, 1) | (x >> 20) & rm(2, 2),
        0b0000000000000000000011 => (x >> 10) & rm(2, 0) | (x >> 20) & rm(2, 2),
        0b0000000000000000000010 => x & rm(3, 0) | (x >> 10) & rm(2, 3),
        0b0100000000010000000001 => (x >> 30) & rm(3, 0),
        0b0100000000010000000000 => x & rm(1, 0) | (x >> 20) & rm(3, 1),
        0b0100000000000000000001 => (x >> 10) & rm(1, 0) | (x >> 20) & rm(3, 1),
        0b0100000000000000000000 => x & rm(2, 0) | (x >> 10) & rm(3, 2),
        0b0000000000010000000001 => (x >> 20) & rm(4, 0),
        0b0000000000010000000000 => x & rm(1, 0) | (x >> 10) & rm(4, 1),
        0b0000000000000000000001 => (x >> 10) & rm(5, 0),
        0b0000000000000000000000 => x, // & row_mask(6, 0),
        _ => unreachable!(),
    }
}

pub fn insert_filled_row(x: u64, mask: u64) -> u64 {
    insert_filled_row_inner(x, wrapper(mask))
}

fn insert_filled_row_inner(x: u64, mask: u64) -> u64 {
    match mask {
        0b1100000000110000000011 => 0xfffffffffffffff,
        0b1100000000110000000010 => x & rm(1, 0) | 0xffffffffffffc00,
        0b1100000000100000000011 => (x & rm(1, 0)) << 10 | 0xffffffffff003ff,
        0b1100000000100000000010 => x & rm(2, 0) | 0xffffffffff00000,
        0b1000000000110000000011 => (x & rm(1, 0)) << 20 | 0xfffffffc00fffff,
        0b1000000000110000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 10 | 0xfffffffc00ffc00,
        0b1000000000100000000011 => (x & rm(2, 0)) << 10 | 0xfffffffc00003ff,
        0b1000000000100000000010 => x & rm(3, 0) | 0xfffffffc0000000,
        0b1100000000110000000001 => (x & rm(1, 0)) << 30 | 0xfffff003fffffff,
        0b1100000000110000000000 => x & rm(1, 0) | (x & rm(1, 1)) << 20 | 0xfffff003ffffc00,
        0b1100000000100000000001 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 20 | 0xfffff003ff003ff,
        0b1100000000100000000000 => x & rm(2, 0) | (x & rm(1, 2)) << 10 | 0xfffff003ff00000,
        0b1000000000110000000001 => (x & rm(2, 0)) << 20 | 0xfffff00000fffff,
        0b1000000000110000000000 => x & rm(1, 0) | (x & rm(2, 1)) << 10 | 0xfffff00000ffc00,
        0b1000000000100000000001 => (x & rm(3, 0)) << 10 | 0xfffff00000003ff,
        0b1000000000100000000000 => x & rm(4, 0) | 0xfffff0000000000,
        0b1100000000010000000011 => (x & rm(1, 0)) << 40 | 0xffc00ffffffffff,
        0b1100000000010000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 30 | 0xffc00fffffffc00,
        0b1100000000000000000011 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 30 | 0xffc00fffff003ff,
        0b1100000000000000000010 => x & rm(2, 0) | (x & rm(1, 2)) << 20 | 0xffc00fffff00000,
        0b1000000000010000000011 => (x & rm(1, 0)) << 20 | (x & rm(1, 1)) << 30 | 0xffc00ffc00fffff,
        0b1000000000010000000010 => {
            x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(1, 2)) << 20 | 0xffc00ffc00ffc00
        }
        0b1000000000000000000011 => (x & rm(2, 0)) << 10 | (x & rm(1, 2)) << 20 | 0xffc00ffc00003ff,
        0b1000000000000000000010 => x & rm(3, 0) | (x & rm(1, 3)) << 10 | 0xffc00ffc0000000,
        0b1100000000010000000001 => (x & rm(2, 0)) << 30 | 0xffc00003fffffff,
        0b1100000000010000000000 => x & rm(1, 0) | (x & rm(2, 1)) << 20 | 0xffc00003ffffc00,
        0b1100000000000000000001 => (x & rm(1, 0)) << 10 | (x & rm(2, 1)) << 20 | 0xffc00003ff003ff,
        0b1100000000000000000000 => x & rm(2, 0) | (x & rm(2, 2)) << 10 | 0xffc00003ff00000,
        0b1000000000010000000001 => (x & rm(3, 0)) << 20 | 0xffc0000000fffff,
        0b1000000000010000000000 => x & rm(1, 0) | (x & rm(3, 1)) << 10 | 0xffc0000000ffc00,
        0b1000000000000000000001 => (x & rm(4, 0)) << 10 | 0xffc0000000003ff,
        0b1000000000000000000000 => x & rm(5, 0) | 0xffc000000000000,
        0b0100000000110000000011 => (x & rm(1, 0)) << 50 | 0x3ffffffffffff,
        0b0100000000110000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 40 | 0x3fffffffffc00,
        0b0100000000100000000011 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 40 | 0x3fffffff003ff,
        0b0100000000100000000010 => x & rm(2, 0) | (x & rm(1, 2)) << 30 | 0x3fffffff00000,
        0b0000000000110000000011 => (x & rm(1, 0)) << 20 | (x & rm(1, 1)) << 40 | 0x3ffffc00fffff,
        0b0000000000110000000010 => {
            x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(1, 2)) << 30 | 0x3ffffc00ffc00
        }
        0b0000000000100000000011 => (x & rm(2, 0)) << 10 | (x & rm(1, 2)) << 30 | 0x3ffffc00003ff,
        0b0000000000100000000010 => x & rm(3, 0) | (x & rm(1, 3)) << 20 | 0x3ffffc0000000,
        0b0100000000110000000001 => (x & rm(1, 0)) << 30 | (x & rm(1, 1)) << 40 | 0x3ff003fffffff,
        0b0100000000110000000000 => {
            x & rm(1, 0) | (x & rm(1, 1)) << 20 | (x & rm(1, 2)) << 30 | 0x3ff003ffffc00
        }
        0b0100000000100000000001 => {
            (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 20 | (x & rm(1, 2)) << 30 | 0x3ff003ff003ff
        }
        0b0100000000100000000000 => {
            x & rm(2, 0) | (x & rm(1, 2)) << 10 | (x & rm(1, 3)) << 20 | 0x3ff003ff00000
        }
        0b0000000000110000000001 => (x & rm(2, 0)) << 20 | (x & rm(1, 2)) << 30 | 0x3ff00000fffff,
        0b0000000000110000000000 => {
            x & rm(1, 0) | (x & rm(2, 1)) << 10 | (x & rm(1, 3)) << 20 | 0x3ff00000ffc00
        }
        0b0000000000100000000001 => (x & rm(3, 0)) << 10 | (x & rm(1, 3)) << 20 | 0x3ff00000003ff,
        0b0000000000100000000000 => x & rm(4, 0) | (x & rm(1, 4)) << 10 | 0x3ff0000000000,
        0b0100000000010000000011 => (x & rm(2, 0)) << 40 | 0xffffffffff,
        0b0100000000010000000010 => x & rm(1, 0) | (x & rm(2, 1)) << 30 | 0xfffffffc00,
        0b0100000000000000000011 => (x & rm(1, 0)) << 10 | (x & rm(2, 1)) << 30 | 0xfffff003ff,
        0b0100000000000000000010 => x & rm(2, 0) | (x & rm(2, 2)) << 20 | 0xfffff00000,
        0b0000000000010000000011 => (x & rm(1, 0)) << 20 | (x & rm(2, 1)) << 30 | 0xffc00fffff,
        0b0000000000010000000010 => {
            x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(2, 2)) << 20 | 0xffc00ffc00
        }
        0b0000000000000000000011 => (x & rm(2, 0)) << 10 | (x & rm(2, 2)) << 20 | 0xffc00003ff,
        0b0000000000000000000010 => x & rm(3, 0) | (x & rm(2, 3)) << 10 | 0xffc0000000,
        0b0100000000010000000001 => (x & rm(3, 0)) << 30 | 0x3fffffff,
        0b0100000000010000000000 => x & rm(1, 0) | (x & rm(3, 1)) << 20 | 0x3ffffc00,
        0b0100000000000000000001 => (x & rm(1, 0)) << 10 | (x & rm(3, 1)) << 20 | 0x3ff003ff,
        0b0100000000000000000000 => x & rm(2, 0) | (x & rm(3, 2)) << 10 | 0x3ff00000,
        0b0000000000010000000001 => (x & rm(4, 0)) << 20 | 0xfffff,
        0b0000000000010000000000 => x & rm(1, 0) | (x & rm(4, 1)) << 10 | 0xffc00,
        0b0000000000000000000001 => (x & rm(5, 0)) << 10 | 0x3ff,
        0b0000000000000000000000 => x, // & row_mask(6, 0) | 0x0,
        _ => unreachable!(),
    }
}

pub fn insert_blank_row(x: u64, mask: u64) -> u64 {
    insert_blank_row_inner(x, wrapper(mask))
}

fn insert_blank_row_inner(x: u64, mask: u64) -> u64 {
    match mask {
        0b1100000000110000000011 => 0,
        0b1100000000110000000010 => x & rm(1, 0),
        0b1100000000100000000011 => (x & rm(1, 0)) << 10,
        0b1100000000100000000010 => x & rm(2, 0),
        0b1000000000110000000011 => (x & rm(1, 0)) << 20,
        0b1000000000110000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 10,
        0b1000000000100000000011 => (x & rm(2, 0)) << 10,
        0b1000000000100000000010 => x & rm(3, 0),
        0b1100000000110000000001 => (x & rm(1, 0)) << 30,
        0b1100000000110000000000 => x & rm(1, 0) | (x & rm(1, 1)) << 20,
        0b1100000000100000000001 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 20,
        0b1100000000100000000000 => x & rm(2, 0) | (x & rm(1, 2)) << 10,
        0b1000000000110000000001 => (x & rm(2, 0)) << 20,
        0b1000000000110000000000 => x & rm(1, 0) | (x & rm(2, 1)) << 10,
        0b1000000000100000000001 => (x & rm(3, 0)) << 10,
        0b1000000000100000000000 => x & rm(4, 0),
        0b1100000000010000000011 => (x & rm(1, 0)) << 40,
        0b1100000000010000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 30,
        0b1100000000000000000011 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 30,
        0b1100000000000000000010 => x & rm(2, 0) | (x & rm(1, 2)) << 20,
        0b1000000000010000000011 => (x & rm(1, 0)) << 20 | (x & rm(1, 1)) << 30,
        0b1000000000010000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(1, 2)) << 20,
        0b1000000000000000000011 => (x & rm(2, 0)) << 10 | (x & rm(1, 2)) << 20,
        0b1000000000000000000010 => x & rm(3, 0) | (x & rm(1, 3)) << 10,
        0b1100000000010000000001 => (x & rm(2, 0)) << 30,
        0b1100000000010000000000 => x & rm(1, 0) | (x & rm(2, 1)) << 20,
        0b1100000000000000000001 => (x & rm(1, 0)) << 10 | (x & rm(2, 1)) << 20,
        0b1100000000000000000000 => x & rm(2, 0) | (x & rm(2, 2)) << 10,
        0b1000000000010000000001 => (x & rm(3, 0)) << 20,
        0b1000000000010000000000 => x & rm(1, 0) | (x & rm(3, 1)) << 10,
        0b1000000000000000000001 => (x & rm(4, 0)) << 10,
        0b1000000000000000000000 => x & rm(5, 0),
        0b0100000000110000000011 => (x & rm(1, 0)) << 50,
        0b0100000000110000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 40,
        0b0100000000100000000011 => (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 40,
        0b0100000000100000000010 => x & rm(2, 0) | (x & rm(1, 2)) << 30,
        0b0000000000110000000011 => (x & rm(1, 0)) << 20 | (x & rm(1, 1)) << 40,
        0b0000000000110000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(1, 2)) << 30,
        0b0000000000100000000011 => (x & rm(2, 0)) << 10 | (x & rm(1, 2)) << 30,
        0b0000000000100000000010 => x & rm(3, 0) | (x & rm(1, 3)) << 20,
        0b0100000000110000000001 => (x & rm(1, 0)) << 30 | (x & rm(1, 1)) << 40,
        0b0100000000110000000000 => x & rm(1, 0) | (x & rm(1, 1)) << 20 | (x & rm(1, 2)) << 30,
        0b0100000000100000000001 => {
            (x & rm(1, 0)) << 10 | (x & rm(1, 1)) << 20 | (x & rm(1, 2)) << 30
        }
        0b0100000000100000000000 => x & rm(2, 0) | (x & rm(1, 2)) << 10 | (x & rm(1, 3)) << 20,
        0b0000000000110000000001 => (x & rm(2, 0)) << 20 | (x & rm(1, 2)) << 30,
        0b0000000000110000000000 => x & rm(1, 0) | (x & rm(2, 1)) << 10 | (x & rm(1, 3)) << 20,
        0b0000000000100000000001 => (x & rm(3, 0)) << 10 | (x & rm(1, 3)) << 20,
        0b0000000000100000000000 => x & rm(4, 0) | (x & rm(1, 4)) << 10,
        0b0100000000010000000011 => (x & rm(2, 0)) << 40,
        0b0100000000010000000010 => x & rm(1, 0) | (x & rm(2, 1)) << 30,
        0b0100000000000000000011 => (x & rm(1, 0)) << 10 | (x & rm(2, 1)) << 30,
        0b0100000000000000000010 => x & rm(2, 0) | (x & rm(2, 2)) << 20,
        0b0000000000010000000011 => (x & rm(1, 0)) << 20 | (x & rm(2, 1)) << 30,
        0b0000000000010000000010 => x & rm(1, 0) | (x & rm(1, 1)) << 10 | (x & rm(2, 2)) << 20,
        0b0000000000000000000011 => (x & rm(2, 0)) << 10 | (x & rm(2, 2)) << 20,
        0b0000000000000000000010 => x & rm(3, 0) | (x & rm(2, 3)) << 10,
        0b0100000000010000000001 => (x & rm(3, 0)) << 30,
        0b0100000000010000000000 => x & rm(1, 0) | (x & rm(3, 1)) << 20,
        0b0100000000000000000001 => (x & rm(1, 0)) << 10 | (x & rm(3, 1)) << 20,
        0b0100000000000000000000 => x & rm(2, 0) | (x & rm(3, 2)) << 10,
        0b0000000000010000000001 => (x & rm(4, 0)) << 20,
        0b0000000000010000000000 => x & rm(1, 0) | (x & rm(4, 1)) << 10,
        0b0000000000000000000001 => (x & rm(5, 0)) << 10,
        0b0000000000000000000000 => x, // & row_mask(6, 0),
        _ => unreachable!(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        sfinder_core::field::{
            field::Field,
            key_operators::{get_delete_bit_key, get_delete_key},
            small_field::SmallField,
        },
        sfinder_lib::boolean_walker,
    };
    use rand::{thread_rng, Rng};

    #[test]
    fn test_delete_row() {
        let mut rngs = thread_rng();
        for booleans in boolean_walker::walk(6) {
            let mut field = SmallField::new();
            let mut expect = SmallField::new();

            let mut expect_y = 0;
            for (y, &boolean) in booleans.iter().enumerate() {
                if boolean {
                    // ラインを全て埋める
                    for x in 0..10 {
                        field.set_block(x, y as u8);
                    }
                } else {
                    // ラインを全て埋めない
                    for x in 0..10 {
                        if rngs.gen_bool(0.8) {
                            field.set_block(x, y as u8);
                            expect.set_block(x, expect_y);
                        }
                    }

                    let remove_x = rngs.gen_range(0..10);
                    field.remove_block(remove_x, y as u8);
                    expect.remove_block(remove_x, expect_y);

                    expect_y += 1;
                }
            }

            let board = field.get_x_board();
            let delete_key = get_delete_key(board);
            assert_eq!(delete_row(board, delete_key), expect.get_x_board());
        }
    }

    #[test]
    fn test_insert_filled_row() {
        let mut rngs = thread_rng();
        for booleans in boolean_walker::walk(6) {
            let mut field = SmallField::new();
            let mut expect = SmallField::new();
            let mut delete_key = 0;

            let mut expect_y = 0;
            for (y, &boolean) in booleans.iter().enumerate() {
                if boolean {
                    // ラインを全て埋める
                    for x in 0..10 {
                        expect.set_block(x, y as u8);
                    }
                    delete_key |= get_delete_bit_key(y as u8);
                } else {
                    // ラインを全て埋めない
                    for x in 0..10 {
                        if rngs.gen_bool(0.8) {
                            expect.set_block(x, y as u8);
                            field.set_block(x, expect_y);
                        }
                    }

                    let remove_x = rngs.gen_range(0..10);
                    expect.remove_block(remove_x, y as u8);
                    field.remove_block(remove_x, expect_y);

                    expect_y += 1;
                }
            }

            let board = field.get_x_board();
            assert_eq!(insert_filled_row(board, delete_key), expect.get_x_board());
        }
    }

    #[test]
    fn test_insert_blank_row() {
        let mut rngs = thread_rng();
        for booleans in boolean_walker::walk(6) {
            let mut expect = SmallField::new();
            let mut field = SmallField::new();
            let mut delete_key = 0;

            let mut expect_y = 0;
            for (y, &boolean) in booleans.iter().enumerate() {
                if boolean {
                    // ラインを空白にする
                    delete_key |= get_delete_bit_key(y as u8);
                } else {
                    // ラインを全て埋めない
                    for x in 0..10 {
                        if rngs.gen_bool(0.8) {
                            expect.set_block(x, y as u8);
                            field.set_block(x, expect_y);
                        }
                    }

                    let remove_x = rngs.gen_range(0..10);
                    expect.remove_block(remove_x, y as u8);
                    field.remove_block(remove_x, expect_y);

                    expect_y += 1;
                }
            }

            let board = field.get_x_board();
            assert_eq!(insert_blank_row(board, delete_key), expect.get_x_board());
        }
    }
}
