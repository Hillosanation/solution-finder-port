/// Helper function to writing repeating a bit pattern for all rows on a board. This should be evaluated at compile time.
const fn repeat_rows(row_mask: u64) -> u64 {
    // assert cannot be used in const fn
    if row_mask & !0x3ff != 0 {
        panic!("invalid row mask");
    }
    row_mask | row_mask << 10 | row_mask << 20 | row_mask << 30 | row_mask << 40 | row_mask << 50
}

/// Folds each row in the board to signify which rows are completely filled.
pub const fn get_delete_key(board: u64) -> u64 {
    let b0101010101 = (board & repeat_rows(0b1010101010)) >> 1 & board;
    let b0000010101 = (b0101010101 & repeat_rows(0b0101010000)) >> 4 & b0101010101;
    let b0000000101 = (b0000010101 & repeat_rows(0b0000010100)) >> 2 & b0000010101;
    (b0000000101 & repeat_rows(0b0000000100)) >> 2 & b0000000101
}

const KEY_MASKS: [u64; 25] = [
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000000000,
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000000001,
    0b0000000000_0000000000_0000000000_0000000000_0000000001_0000000001,
    0b0000000000_0000000000_0000000000_0000000001_0000000001_0000000001,
    0b0000000000_0000000000_0000000001_0000000001_0000000001_0000000001,
    0b0000000000_0000000001_0000000001_0000000001_0000000001_0000000001,
    0b0000000001_0000000001_0000000001_0000000001_0000000001_0000000001,
    0b0000000001_0000000001_0000000001_0000000001_0000000001_0000000011,
    0b0000000001_0000000001_0000000001_0000000001_0000000011_0000000011,
    0b0000000001_0000000001_0000000001_0000000011_0000000011_0000000011,
    0b0000000001_0000000001_0000000011_0000000011_0000000011_0000000011,
    0b0000000001_0000000011_0000000011_0000000011_0000000011_0000000011,
    0b0000000011_0000000011_0000000011_0000000011_0000000011_0000000011,
    0b0000000011_0000000011_0000000011_0000000011_0000000011_0000000111,
    0b0000000011_0000000011_0000000011_0000000011_0000000111_0000000111,
    0b0000000011_0000000011_0000000011_0000000111_0000000111_0000000111,
    0b0000000011_0000000011_0000000111_0000000111_0000000111_0000000111,
    0b0000000011_0000000111_0000000111_0000000111_0000000111_0000000111,
    0b0000000111_0000000111_0000000111_0000000111_0000000111_0000000111,
    0b0000000111_0000000111_0000000111_0000000111_0000000111_0000001111,
    0b0000000111_0000000111_0000000111_0000000111_0000001111_0000001111,
    0b0000000111_0000000111_0000000111_0000001111_0000001111_0000001111,
    0b0000000111_0000000111_0000001111_0000001111_0000001111_0000001111,
    0b0000000111_0000001111_0000001111_0000001111_0000001111_0000001111,
    0b0000001111_0000001111_0000001111_0000001111_0000001111_0000001111,
];

// y行上のブロックは対象に含まない
// TODO: Make a better type wrapper for Keys
/// Crashes if y > 24
pub fn get_mask_for_key_below_y(y: u8) -> u64 {
    KEY_MASKS[y as usize]
}

// y行上のブロックは対象に含む
pub fn get_mask_for_key_above_y(y: u8) -> u64 {
    repeat_rows(0b0000001111) - get_mask_for_key_below_y(y)
}

#[cfg(test)]
pub fn get_bit_keys(ys: &[u8]) -> u64 {
    ys.iter()
        .map(|&y| get_bit_key(y))
        .fold(0, std::ops::BitOr::bitor)
}

// TODO: inline this function
pub fn get_delete_bit_key(y: u8) -> u64 {
    get_bit_key(y)
}

const BIT_KEY_MASKS: [u64; 24] = [
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000000001,
    0b0000000000_0000000000_0000000000_0000000000_0000000001_0000000000,
    0b0000000000_0000000000_0000000000_0000000001_0000000000_0000000000,
    0b0000000000_0000000000_0000000001_0000000000_0000000000_0000000000,
    0b0000000000_0000000001_0000000000_0000000000_0000000000_0000000000,
    0b0000000001_0000000000_0000000000_0000000000_0000000000_0000000000,
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000000010,
    0b0000000000_0000000000_0000000000_0000000000_0000000010_0000000000,
    0b0000000000_0000000000_0000000000_0000000010_0000000000_0000000000,
    0b0000000000_0000000000_0000000010_0000000000_0000000000_0000000000,
    0b0000000000_0000000010_0000000000_0000000000_0000000000_0000000000,
    0b0000000010_0000000000_0000000000_0000000000_0000000000_0000000000,
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000000100,
    0b0000000000_0000000000_0000000000_0000000000_0000000100_0000000000,
    0b0000000000_0000000000_0000000000_0000000100_0000000000_0000000000,
    0b0000000000_0000000000_0000000100_0000000000_0000000000_0000000000,
    0b0000000000_0000000100_0000000000_0000000000_0000000000_0000000000,
    0b0000000100_0000000000_0000000000_0000000000_0000000000_0000000000,
    0b0000000000_0000000000_0000000000_0000000000_0000000000_0000001000,
    0b0000000000_0000000000_0000000000_0000000000_0000001000_0000000000,
    0b0000000000_0000000000_0000000000_0000001000_0000000000_0000000000,
    0b0000000000_0000000000_0000001000_0000000000_0000000000_0000000000,
    0b0000000000_0000001000_0000000000_0000000000_0000000000_0000000000,
    0b0000001000_0000000000_0000000000_0000000000_0000000000_0000000000,
];

// TODO: check if using 1 << (y % 6 * 10 + y / 6) instead is good enough
/// Panics if y > 23
pub fn get_bit_key(y: u8) -> u64 {
    BIT_KEY_MASKS[y as usize]
}

pub const fn mirror(mut field: u64) -> u64 {
    field = (field & repeat_rows(0b1111100000)) >> 5 | (field & repeat_rows(0b0000011111)) << 5;

    let fixed = field & repeat_rows(0b0010000100);

    field &= repeat_rows(0b1101111011);

    field = (field & repeat_rows(0b1100011000)) >> 3 | (field & repeat_rows(0b0001100011)) << 3;

    field = (field & repeat_rows(0b1001010010)) >> 1 | (field & repeat_rows(0b0100101001)) << 1;

    field | fixed
}

// The last step is necessary because we are ORing the cells unlike delete key,
pub const fn get_using_key(board: u64) -> u64 {
    let b0101010101 = (board & repeat_rows(0b1010101010)) >> 1 | board;
    let b0000010101 = (b0101010101 & repeat_rows(0b0101010000)) >> 4 | b0101010101;
    let b0000000101 = (b0000010101 & repeat_rows(0b0000010100)) >> 2 | b0000010101;
    let b0000000001 = (b0000000101 & repeat_rows(0b0000000100)) >> 2 | b0000000101;

    b0000000001 & repeat_rows(0b0000000001)
}

// keyのうち1ビットがオンになっているとき、そのビットのy座標を返却
pub fn bit_to_y_from_key(key: u64) -> u8 {
    assert_eq!(
        (key & repeat_rows(0b0000001111)).count_ones(),
        1,
        "{key:0b}"
    );

    if let low @ 1.. = key & repeat_rows(0b0000000001) {
        todo!()
    } else if let mid_low @ 1.. = key & repeat_rows(0b0000000010) {
        todo!()
    } else if let mid_high @ 1.. = key & repeat_rows(0b0000000100) {
        todo!()
    } else {
        let high = key & repeat_rows(0b0000001000);
        todo!()
    }
}

// keyのうち、最も低い行のbitを取り出す
pub fn extract_lower_bit(key: u64) -> u64 {
    pub const fn get_lowest_bit(x: u64) -> u64 {
        // compiles down to the same thing as x & -x in -O
        (x as i64 & -(x as i64)) as u64
    }

    assert!(
        (key & repeat_rows(0b0000001111)).count_ones() >= 1,
        "{key:0b}"
    );

    if let low @ 1.. = key & repeat_rows(0b0000000001) {
        get_lowest_bit(low)
    } else if let mid_low @ 1.. = key & repeat_rows(0b0000000010) {
        get_lowest_bit(mid_low)
    } else if let mid_high @ 1.. = key & repeat_rows(0b0000000100) {
        get_lowest_bit(mid_high)
    } else {
        let high = key & repeat_rows(0b0000001000);
        get_lowest_bit(high)
    }
}

pub fn to_column_key(bit_key: u64) -> u64 {
    (0..24)
        .filter(|&y| bit_key & get_bit_key(y) != 0)
        .map(get_column_key)
        .fold(0, std::ops::BitOr::bitor)
}

pub const fn get_column_key(y: u8) -> u64 {
    1 << y
}

pub fn to_bit_key(column_key: u64) -> u64 {
    (0..24)
        .filter(|&y| column_key & get_column_key(y) != 0)
        .map(get_bit_key)
        .fold(0, std::ops::BitOr::bitor)
}

#[cfg(test)]
mod tests {
    use super::*;

    // todo, implement BitOperators first
}
