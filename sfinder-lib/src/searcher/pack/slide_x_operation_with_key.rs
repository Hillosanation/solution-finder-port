//! Generated by SlideXSeparableMino

use crate::{
    common::datastore::{
        action::action::Action, mino_operation::MinoOperation,
        mino_operation_with_key::MinoOperationWithKey, operation::Operation,
        operation_with_key::OperationWithKey,
    },
    sfinder_core::mino::mino::Mino,
};

#[derive(Debug)]
pub struct SlideXOperationWithKey<Op: MinoOperationWithKey> {
    operation_with_key: Op,
    slide_x: u8,
}

impl<Op: MinoOperationWithKey> SlideXOperationWithKey<Op> {
    pub fn new(operation_with_key: Op, slide_x: u8) -> Self {
        Self {
            operation_with_key,
            slide_x,
        }
    }
}

impl<Op: MinoOperationWithKey> Action for SlideXOperationWithKey<Op> {
    fn get_x(&self) -> u8 {
        self.operation_with_key.get_x() + self.slide_x
    }

    fn get_y(&self) -> u8 {
        self.operation_with_key.get_y()
    }

    fn get_rotate(&self) -> crate::sfinder_core::srs::rotate::Rotate {
        self.operation_with_key.get_rotate()
    }
}

impl<Op: MinoOperationWithKey> Operation for SlideXOperationWithKey<Op> {
    fn get_piece(&self) -> crate::sfinder_core::mino::piece::Piece {
        self.operation_with_key.get_piece()
    }
}

impl<Op: MinoOperationWithKey> OperationWithKey for SlideXOperationWithKey<Op> {
    fn get_using_key(&self) -> u64 {
        self.operation_with_key.get_using_key()
    }

    fn get_need_deleted_key(&self) -> u64 {
        self.operation_with_key.get_need_deleted_key()
    }
}

impl<Op: MinoOperationWithKey> MinoOperation for SlideXOperationWithKey<Op> {
    fn get_mino(&self) -> &Mino {
        self.operation_with_key.get_mino()
    }
}

impl<Op: MinoOperationWithKey> MinoOperationWithKey for SlideXOperationWithKey<Op> {}

impl<Op: MinoOperationWithKey> PartialEq for SlideXOperationWithKey<Op> {
    fn eq(&self, other: &Self) -> bool {
        <dyn MinoOperationWithKey>::eq(self, other)
    }
}

#[cfg(test)]
mod tests {
    use rand::{thread_rng, Rng};

    use crate::{
        common::datastore::full_operation_with_key::FullOperationWithKey,
        sfinder_core::field::field_constants::FIELD_WIDTH, sfinder_lib::randoms,
    };

    use super::*;

    #[test]
    fn get() {
        let mut rngs = thread_rng();

        for _ in 0..10000 {
            let piece = randoms::gen_piece(&mut rngs);
            let rotate = randoms::gen_rotate(&mut rngs);
            let mino = Mino::new(piece, rotate);

            let operation_with_key = FullOperationWithKey::new(
                &mino,
                rngs.gen_range(0..FIELD_WIDTH),
                rngs.gen_range(0..10),
                randoms::gen_key(&mut rngs),
                randoms::gen_key(&mut rngs),
            );

            let slide = rngs.gen_range(0..4);
            let slide_mopk = SlideXOperationWithKey::new(operation_with_key.clone(), slide);

            assert_eq!(slide_mopk.get_x(), operation_with_key.get_x() + slide);
            assert_eq!(slide_mopk.get_y(), operation_with_key.get_y());
            assert_eq!(slide_mopk.get_rotate(), operation_with_key.get_rotate());
            assert_eq!(slide_mopk.get_piece(), operation_with_key.get_piece());
        }
    }
}
